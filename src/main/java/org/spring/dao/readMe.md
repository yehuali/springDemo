DAO异常体系都继承于DataAccessException(继承于NestedRuntimeException)
NestedRuntimeException异常以嵌套的方式封装了源异常
  -->getCause()：获取原始的异常信息

Spring以分类手法建立了异常分类目录 
  --->可以选择感兴趣的异常加以处理

Spring对新的持久化技术提供支持--->为其定义一个对应的子异常就可以（符合"开闭原则"）
（1）准备资源
（2）启动事务
（3）在事务中执行具体的数据访问操作
（4）提交/回滚事务
（5）关闭资源，处理异常
--->将数据访问中固定和变化的部分分开，同时保证模板类是线程安全的
   变化部分通过回调接口开放出来：数据访问和结果返回
   
持久化技术的支持类都继承于dao.support.DaoSupport类（实现了InitializingBean接口）
在afterPropertiesSet()接口方法中检查模板对象和数据源是否被正确设置
===============================================================================================================

ACID:原子性 一致性 隔离性  持久性
数据库管理系统一般采用重执行日志来操作原子性、一致性和持久性
重执行日志记录了数据库变化的每一个动作
-->发生错误，数据库可根据重执行日志撤销已经执行的操作

数据库管理系统采用数据库锁机制保证事务的隔离性
1.数据并发的问题
  -->数据读问题：
        脏读：读到其他事务尚未提交的数据
        不可重复读:读到已经提交事务的更改数据（更改或删除） --->数据添加行级锁
        幻象读：读到其他已经提交事务新增数据 ---> 表级锁
     数据更新问题：第一类丢失更新和第二类丢失更新
     
数据库锁机制
锁定对象：表锁定和行锁定
并发事务锁定：
        共享锁定：防止独占锁定，但允许其他的共享锁定
        独占锁定：防止其他的独占锁定，也防止其他的共享锁定
        
 事务隔离级别：
    直接使用锁管理麻烦，数据库为用户提供自动锁机制
    --->用户指定会话的事务隔离级别 
        如果一个资源上的锁数目太多，自动进行锁升级提高系统的运行性能
  
   READ UNCOMMITED
   READ COMMITTED
   REPEATABLE READ
   SERIALIZABLE
   
Savepoint接口允许用户将事务分割为多个阶段，用户可以指定回滚到事务的特定保存点

=======================================================================================
ThreadLocal为每个使用该变量的线程分配一个独立的变量副本
 1.InheritableThreadLocal继承于ThreadLocal
    --->自动为子线程复制一份从父线程那里继承而来的本地变量
    
 ThreadLocal接口方法
   1.void set(Object value):设置当前线程的线程局部变量的值
   2.public Object get():返回当前线程所对应的线程局部变量
   3.public void remove()
   4.protected Object initialValue():返回该线程局部变量的初始值，延迟调用，在get()或set()执行，并且仅执行一次
   
 同步机制采用了“以时间换空间”的方式，访问串行化，对象共享化
 ThrealLocal采用了"以空间换时间"的方式，访问并行化，对象独享化
    

      
     
  

   
